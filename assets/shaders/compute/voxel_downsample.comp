#version 430 core

// WORKGROUP SIZE (64 THREADS PER GROUP)
layout(local_size_x = 64) in;

// POINT DATA STRUCTURE (16-BYTE ALIGNED)
struct PointData {
    vec3 position;
    float intensity;
};

// INPUT BUFFER (READ-ONLY POINT CLOUD DATA)
layout(std430, binding = 0) restrict readonly buffer InputPointBuffer {
    PointData inputPoints[];
};

// OUTPUT BUFFER (WRITE-ONLY DOWNSAMPLED POINTS)
layout(std430, binding = 1) restrict writeonly buffer OutputPointBuffer {
    PointData outputPoints[];
};

// ATOMIC COUNTER (TRACKS NUMBER OF OUTPUT POINTS WRITTEN)
layout(std430, binding = 2) restrict buffer OutputCounterBuffer {
    uint outputCounter;
};

// HASH TABLE (STORES SIMPLE HASH KEYS OF VOXEL COORDINATES)
// EACH ENTRY IS 1 UINT: HASH VALUE (0 = EMPTY, NON-ZERO = OCCUPIED)
layout(std430, binding = 3) restrict buffer VoxelHashBuffer {
    uint voxelHash[]; // SIMPLE HASH VALUES OF VOXEL COORDINATES
};

// UNIFORMS (PARAMETERS PASSED FROM CPU)
uniform float voxelSize;            // SIZE OF EACH VOXEL CUBE
uniform uint maxOutputPoints;       // MAXIMUM ALLOWED OUTPUT POINTS
uniform uint hashTableSize;         // SIZE OF HASH TABLE ARRAY

// HASH FUNCTION FOR 3D VOXEL COORDINATES
uint hash3D(ivec3 coord) {
    // SIMPLE BUT EFFECTIVE HASH WITH LARGE PRIMES
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;  
    const uint p3 = 83492791u;
    
    uint h = uint(coord.x) * p1;
    h ^= uint(coord.y) * p2;
    h ^= uint(coord.z) * p3;
    
    // ENSURE NON-ZERO RESULT (0 IS RESERVED FOR EMPTY)
    return (h % (hashTableSize - 1u)) + 1u;
}

// CONVERT 3D WORLD POSITION TO DISCRETE VOXEL COORDINATES
// ADDS SMALL EPSILON TO AVOID FLOATING POINT BOUNDARY ISSUES
ivec3 voxelCoords(vec3 pos) {
    return ivec3(floor(pos / voxelSize + 1e-6));
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // BOUNDARY CHECK
    if (index >= inputPoints.length()) return;

    // GET POINT DATA FOR THIS THREAD
    PointData point = inputPoints[index];
    
    // CALCULATE WHICH VOXEL THIS POINT BELONGS TO
    ivec3 voxelCoord = voxelCoords(point.position);
    
    // GENERATE HASH KEY FOR THIS VOXEL
    uint voxelKey = hash3D(voxelCoord);

    // FIND HASH TABLE SLOT USING LINEAR PROBING
    uint hashIndex = voxelKey % hashTableSize;
    bool inserted = false;

    // LINEAR PROBING - TRY UP TO 64 SLOTS
    for (uint probe = 0u; probe < 64u && !inserted; probe++) {
        uint existingKey = voxelHash[hashIndex];
        
        if (existingKey == 0u) {
            // SLOT IS EMPTY - TRY TO CLAIM IT
            uint claimedKey = atomicCompSwap(voxelHash[hashIndex], 0u, voxelKey);
            
            if (claimedKey == 0u) {
                // SUCCESSFULLY CLAIMED - ADD POINT TO OUTPUT
                uint outIdx = atomicAdd(outputCounter, 1u);
                if (outIdx < maxOutputPoints) {
                    outputPoints[outIdx] = point;
                }
                inserted = true;
            }
            // ELSE: SOMEONE ELSE CLAIMED IT, CHECK WHAT THEY PUT
            else if (claimedKey == voxelKey) {
                // SAME VOXEL - DISCARD THIS POINT
                inserted = true;
            }
            // ELSE: DIFFERENT VOXEL - CONTINUE PROBING
        } 
        else if (existingKey == voxelKey) {
            // SAME VOXEL ALREADY OCCUPIED - DISCARD THIS POINT
            inserted = true;
        }
        
        // MOVE TO NEXT SLOT IF NOT INSERTED
        if (!inserted) {
            hashIndex = (hashIndex + 1u) % hashTableSize;
        }
    }
    
    // NOTE: IF PROBING FAILS, POINT IS DISCARDED
    // THIS SHOULD BE RARE WITH PROPER HASH TABLE SIZING
}
