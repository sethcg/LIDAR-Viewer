#version 430 core

// WORKGROUP SIZE (64 THREADS PER GROUP)
layout(local_size_x = 64) in;

// UNIFORMS (PARAMETERS PASSED FROM CPU)
uniform float uVoxelSize;           // SIZE OF EACH VOXEL CUBE
uniform vec3 uVoxelOrigin;          // MINIMUM VOXEL TO USE AS OFFSET
uniform vec3 uVoxelBounds;          // NUMBER OF VOXELS ALONG X, Y, Z
uniform uint uVoxelFlagSize;        // SIZE OF THE ATOMIC OUTPUT FLAG ARRAY

// INPUT BUFFER (READ-ONLY POINT POSITION DATA)
layout(std430, binding = 0) readonly buffer InputPointBuffer {
    vec3 inputPoints[];
};

// OUTPUT BUFFER (WRITE-ONLY KEEP/REMOVE FLAGS)
layout(std430, binding = 1) writeonly buffer OutputFlagBuffer {
    uint outputFlags[];  // 1 KEEP, 0 REMOVE
};

// CONVERT 3D WORLD POSITION TO DISCRETE VOXEL COORDINATES
ivec3 voxelCoords(vec3 position) {
    vec3 shifted = position - uVoxelOrigin;
    return ivec3(floor(shifted / uVoxelSize + 0.5));
}

// FLATTEN THE 3D VOXEL COORDINATES TO A 1D INDEX FOR THE FLAG ARRAY
uint voxelIndex(ivec3 voxelCoord) {
    return voxelCoord.x + voxelCoord.y * uint(uVoxelBounds.x) + voxelCoord.z * uint(uVoxelBounds.x) * uint(uVoxelBounds.y);
}

void main() {
    uint index = gl_GlobalInvocationID.x;

    // KEEP BY DEFAULT
    outputFlags[index] = 1u;

    // BOUNDARY CHECK
    uint inputCount = inputPoints.length();
    if (index >= inputCount) return;

    // GET POINT POSITION FOR THIS THREAD
    vec3 position = inputPoints[index];
    ivec3 voxelCoord = voxelCoords(position);
    
    // CONVERT 3D VOXEL COORDINATES TO 1D INDEX
    uint voxelKey = voxelIndex(voxelCoord);
    
    // ATOMIC FLAG - CHECK IF THIS VOXEL HAS BEEN PROCESSED
    uint currentFlag = atomicExchange(outputFlags[voxelKey % uVoxelFlagSize], 1u);
    if(currentFlag == 1u) {
        // FLAG WAS ALREADY SET, DUPLICATE (REMOVE POINT)
        outputFlags[index] = 0u;
    } else {
        // FLAG WAS NOT SET, NEW POINT (KEEP IT)
        outputFlags[index] = 1u;
    }
}
